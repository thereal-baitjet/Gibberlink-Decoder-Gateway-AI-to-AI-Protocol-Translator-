<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gibberlink Audio → Plain English Demo</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: #333;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: white;
        }

        .header h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .status-bar {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px 20px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
        }

        .ai-status {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.9rem;
        }

        .ai-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .ai-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #ff6b6b;
        }

        .ai-dot.active {
            background: #51cf66;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #ff4757;
            animation: pulse 2s infinite;
        }

        .status-dot.connected {
            background: #2ed573;
        }

        .status-dot.recording {
            background: #ffa502;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .panel {
            background: rgba(255,255,255,0.95);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0,0,0,0.1);
            border: 1px solid rgba(255,255,255,0.2);
        }

        .panel h2 {
            color: #2c3e50;
            margin-bottom: 20px;
            font-size: 1.5rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .panel-icon {
            width: 24px;
            height: 24px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
        }

        .spectrum-container {
            height: 300px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            background: #000;
            position: relative;
            overflow: hidden;
        }

        .spectrum-canvas {
            width: 100%;
            height: 100%;
        }

        .waterfall-container {
            height: 200px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            background: #000;
            position: relative;
            overflow: hidden;
        }

        .waterfall-canvas {
            width: 100%;
            height: 100%;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-success {
            background: linear-gradient(45deg, #2ed573, #1e90ff);
            color: white;
        }

        .btn-danger {
            background: linear-gradient(45deg, #ff4757, #ff3742);
            color: white;
        }

        .btn-secondary {
            background: #f8f9fa;
            color: #6c757d;
            border: 2px solid #e9ecef;
        }

        .device-selector {
            padding: 8px 12px;
            border: 2px solid #e1e8ed;
            border-radius: 6px;
            font-size: 14px;
            background: white;
        }

        .messages-container {
            max-height: 400px;
            overflow-y: auto;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            padding: 15px;
            background: #f8f9fa;
        }

        .message {
            margin-bottom: 15px;
            padding: 15px;
            border-radius: 8px;
            border-left: 4px solid #667eea;
            background: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            animation: slideIn 0.3s ease;
        }

        .message.audio {
            border-left-color: #ffa502;
            background: #fff8e1;
        }

        .message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 12px;
            color: #6c757d;
        }

        .message-type {
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .message-timestamp {
            font-family: monospace;
        }

        .message-content {
            margin-bottom: 10px;
        }

        .message-payload {
            background: #f8f9fa;
            padding: 10px;
            border-radius: 4px;
            font-family: 'Monaco', 'Menlo', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            margin-bottom: 10px;
        }

        .english-translation {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
        }

        .english-text {
            font-size: 14px;
            line-height: 1.5;
            margin-bottom: 10px;
        }

        .confidence-badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
            margin-right: 8px;
        }

        .snr-badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: 600;
        }

        .metrics-panel {
            grid-column: 1 / -1;
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
        }

        .metric-card {
            background: rgba(255,255,255,0.95);
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .metric-number {
            font-size: 1.5rem;
            font-weight: bold;
            color: #667eea;
            margin-bottom: 5px;
        }

        .metric-label {
            color: #6c757d;
            font-size: 12px;
        }

        .quality-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
            margin-top: 5px;
        }

        .quality-bar {
            flex: 1;
            height: 4px;
            background: #e9ecef;
            border-radius: 2px;
            overflow: hidden;
        }

        .quality-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff4757, #ffa502, #2ed573);
            transition: width 0.3s ease;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        @keyframes slideIn {
            from { transform: translateY(20px); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .loading {
            display: inline-block;
            width: 16px;
            height: 16px;
            border: 2px solid #f3f3f3;
            border-top: 2px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .copy-btn {
            background: none;
            border: none;
            color: #667eea;
            cursor: pointer;
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 4px;
            transition: background 0.3s ease;
        }

        .copy-btn:hover {
            background: #f8f9fa;
        }

        @media (max-width: 1200px) {
            .main-grid {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 768px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .controls {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎤 Gibberlink Audio → Plain English</h1>
            <p>Real-time audio capture, demodulation, and plain English translation</p>
        </div>

        <div class="status-bar">
            <div class="status-indicator">
                <div class="status-dot" id="connectionStatus"></div>
                <span id="connectionText">Disconnected</span>
            </div>
            <div class="status-indicator">
                <div class="status-dot" id="audioStatus"></div>
                <span id="audioText">Audio: Stopped</span>
            </div>
            <div class="status-indicator">
                <div class="status-dot" id="translationStatus"></div>
                <span id="translationText">Translation: Stopped</span>
            </div>
            <div class="status-indicator">
                <span>Session: <span id="sessionId">None</span></span>
            </div>
        </div>

        <div class="main-grid">
            <div class="panel">
                <h2>
                    <div class="panel-icon">📊</div>
                    Audio Spectrum
                </h2>
                
                <div class="controls">
                    <button class="btn btn-success" onclick="startAudioCapture()" id="startAudioBtn">
                        🎤 Start Listening
                    </button>
                    <button class="btn btn-danger" onclick="stopAudioCapture()" id="stopAudioBtn" style="display: none;">
                        ⏹️ Stop Listening
                    </button>
                    <button class="btn btn-primary" onclick="startTranslation()" id="startTranslationBtn">
                        🇬🇧 Start Translation
                    </button>
                    <button class="btn btn-secondary" onclick="stopTranslation()" id="stopTranslationBtn" style="display: none;">
                        ⏹️ Stop Translation
                    </button>
                    <button class="btn btn-info" onclick="sendTestMessages()" id="testMessagesBtn">
                        🧪 Send Test Messages
                    </button>
                    <button class="btn btn-warning" onclick="showSampleTranslations()" id="sampleTranslationsBtn">
                        📝 Show Sample Translations
                    </button>
                    <button class="btn btn-success" onclick="forceRealTranslations()" id="forceTranslationsBtn">
                        🚀 Force Real Translations
                    </button>
                    <select class="device-selector" id="deviceSelector">
                        <option value="">Select microphone...</option>
                    </select>
                </div>

                <div class="spectrum-container">
                    <canvas class="spectrum-canvas" id="spectrumCanvas"></canvas>
                </div>

                <div class="waterfall-container">
                    <canvas class="waterfall-canvas" id="waterfallCanvas"></canvas>
                </div>
            </div>

            <div class="panel">
                <h2>
                    <div class="panel-icon">📡</div>
                    Decoded JSON
                </h2>
                
                <div class="messages-container" id="jsonContainer">
                    <div class="message">
                        <div class="message-header">
                            <span class="message-type">System</span>
                            <span class="message-timestamp">Ready for audio</span>
                        </div>
                        <div class="message-content">
                            Start audio capture to see decoded JSON messages here.
                        </div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <h2>
                    <div class="panel-icon">🇬🇧</div>
                    Plain English
                </h2>
                
                <div class="messages-container" id="englishContainer">
                    <div class="message">
                        <div class="message-header">
                            <span class="message-type">System</span>
                            <span class="message-timestamp">Ready for translation</span>
                        </div>
                        <div class="message-content">
                            Audio messages will be translated to plain English here.
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <div class="metrics-panel">
            <div class="metric-card">
                <div class="metric-number" id="framesReceived">0</div>
                <div class="metric-label">Frames Received</div>
            </div>
            <div class="metric-card">
                <div class="metric-number" id="messagesTranslated">0</div>
                <div class="metric-label">Messages Translated</div>
            </div>
            <div class="metric-card">
                <div class="metric-number" id="averageLatency">0ms</div>
                <div class="metric-label">Avg Latency</div>
            </div>
            <div class="metric-card">
                <div class="metric-number" id="averageSnr">0dB</div>
                <div class="metric-label">Avg SNR</div>
                <div class="quality-indicator">
                    <div class="quality-bar">
                        <div class="quality-fill" id="snrBar" style="width: 0%"></div>
                    </div>
                </div>
            </div>
            <div class="metric-card">
                <div class="metric-number" id="averageConfidence">0%</div>
                <div class="metric-label">Avg Confidence</div>
                <div class="quality-indicator">
                    <div class="quality-bar">
                        <div class="quality-fill" id="confidenceBar" style="width: 0%"></div>
                    </div>
                </div>
            </div>
            <div class="metric-card">
                <div class="metric-number" id="crcFailures">0</div>
                <div class="metric-label">CRC Failures</div>
            </div>
        </div>
    </div>

    <script>
        let ws = null;
        let sessionId = null;
        let audioContext = null;
        let analyser = null;
        let microphone = null;
        let spectrumCanvas = null;
        let waterfallCanvas = null;
        let spectrumCtx = null;
        let waterfallCtx = null;
        let isRecording = false;
        let isTranslating = false;
        let translationInterval = null;
        let metrics = {
            framesReceived: 0,
            messagesTranslated: 0,
            averageLatencyMs: 0,
            averageSnrDb: 0,
            averageConfidence: 0,
            crcFailures: 0
        };

        // Initialize canvas
        function initCanvas() {
            spectrumCanvas = document.getElementById('spectrumCanvas');
            waterfallCanvas = document.getElementById('waterfallCanvas');
            spectrumCtx = spectrumCanvas.getContext('2d');
            waterfallCtx = waterfallCanvas.getContext('2d');

            // Set canvas size
            spectrumCanvas.width = spectrumCanvas.offsetWidth;
            spectrumCanvas.height = spectrumCanvas.offsetHeight;
            waterfallCanvas.width = waterfallCanvas.offsetWidth;
            waterfallCanvas.height = waterfallCanvas.offsetHeight;

            // Initialize waterfall data
            waterfallData = new Array(waterfallCanvas.height).fill(0).map(() => new Array(waterfallCanvas.width).fill(0));
        }

        // Draw spectrum
        function drawSpectrum(dataArray) {
            const width = spectrumCanvas.width;
            const height = spectrumCanvas.height;
            
            spectrumCtx.fillStyle = '#000';
            spectrumCtx.fillRect(0, 0, width, height);

            const barWidth = width / dataArray.length;
            let barHeight;
            let x = 0;

            for (let i = 0; i < dataArray.length; i++) {
                barHeight = (dataArray[i] / 255) * height;
                
                // Color based on frequency (Gibberlink tones are typically 1.2-3kHz)
                const hue = (i / dataArray.length) * 360;
                spectrumCtx.fillStyle = `hsl(${hue}, 70%, 60%)`;
                
                spectrumCtx.fillRect(x, height - barHeight, barWidth, barHeight);
                x += barWidth;
            }
        }

        // Draw waterfall
        let waterfallData = [];
        function drawWaterfall(dataArray) {
            const width = waterfallCanvas.width;
            const height = waterfallCanvas.height;

            // Shift existing data down
            waterfallData.shift();
            waterfallData.push([...dataArray]);

            // Draw waterfall
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const dataIndex = Math.floor((x / width) * dataArray.length);
                    const value = waterfallData[y] ? waterfallData[y][dataIndex] || 0 : 0;
                    const intensity = Math.floor((value / 255) * 255);
                    
                    waterfallCtx.fillStyle = `rgb(0, ${intensity}, ${intensity})`;
                    waterfallCtx.fillRect(x, y, 1, 1);
                }
            }
        }

        // Update metrics display
        function updateMetrics() {
            document.getElementById('framesReceived').textContent = metrics.framesReceived;
            document.getElementById('messagesTranslated').textContent = metrics.messagesTranslated;
            document.getElementById('averageLatency').textContent = Math.round(metrics.averageLatencyMs) + 'ms';
            document.getElementById('averageSnr').textContent = Math.round(metrics.averageSnrDb) + 'dB';
            document.getElementById('averageConfidence').textContent = Math.round(metrics.averageConfidence * 100) + '%';
            document.getElementById('crcFailures').textContent = metrics.crcFailures;

            // Update quality bars
            const snrPercent = Math.min(100, Math.max(0, (metrics.averageSnrDb + 10) / 30 * 100));
            document.getElementById('snrBar').style.width = snrPercent + '%';
            
            const confidencePercent = metrics.averageConfidence * 100;
            document.getElementById('confidenceBar').style.width = confidencePercent + '%';
        }

        // Update connection status
        function updateConnectionStatus(connected) {
            const statusDot = document.getElementById('connectionStatus');
            const statusText = document.getElementById('connectionText');

            if (connected) {
                statusDot.classList.add('connected');
                statusText.textContent = 'Connected';
            } else {
                statusDot.classList.remove('connected');
                statusText.textContent = 'Disconnected';
            }
        }

        // Update audio status
        function updateAudioStatus(recording) {
            const statusDot = document.getElementById('audioStatus');
            const statusText = document.getElementById('audioText');
            const startBtn = document.getElementById('startAudioBtn');
            const stopBtn = document.getElementById('stopAudioBtn');

            if (recording) {
                statusDot.classList.add('recording');
                statusText.textContent = 'Audio: Recording';
                startBtn.style.display = 'none';
                stopBtn.style.display = 'inline-flex';
            } else {
                statusDot.classList.remove('recording');
                statusText.textContent = 'Audio: Stopped';
                startBtn.style.display = 'inline-flex';
                stopBtn.style.display = 'none';
            }
        }

        // Add message to container
        function addMessage(containerId, type, content, payload = null, metadata = null) {
            const container = document.getElementById(containerId);
            const message = document.createElement('div');
            message.className = `message ${type}`;

            const timestamp = new Date().toLocaleTimeString();
            const messageId = `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            let messageContent = `
                <div class="message-header">
                    <span class="message-type">${type.toUpperCase()}</span>
                    <span class="message-timestamp">${timestamp}</span>
                </div>
                <div class="message-content">
                    <div>${content}</div>
            `;

            if (payload) {
                messageContent += `
                    <div class="message-payload">
                        <button class="copy-btn" onclick="copyToClipboard('${JSON.stringify(payload).replace(/'/g, "\\'")}')">📋 Copy</button>
                        ${JSON.stringify(payload, null, 2)}
                    </div>
                `;
            }

            if (metadata) {
                messageContent += `
                    <div class="english-translation">
                        <div class="english-text">${metadata.text}</div>
                        <div class="confidence-badge">Confidence: ${Math.round(metadata.confidence * 100)}%</div>
                        <div class="snr-badge">SNR: ${Math.round(metadata.snrDb)}dB</div>
                    </div>
                `;
            }

            messageContent += '</div>';
            message.innerHTML = messageContent;

            container.appendChild(message);
            container.scrollTop = container.scrollHeight;

            // Keep only last 20 messages
            while (container.children.length > 20) {
                container.removeChild(container.firstChild);
            }
        }

        // Copy to clipboard
        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                const notification = document.createElement('div');
                notification.textContent = 'Copied to clipboard!';
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: #2ed573;
                    color: white;
                    padding: 10px 20px;
                    border-radius: 5px;
                    z-index: 1000;
                    animation: slideIn 0.3s ease;
                `;
                document.body.appendChild(notification);
                setTimeout(() => notification.remove(), 2000);
            });
        }

        // Establish session
        async function establishSession() {
            try {
                const response = await fetch('http://localhost:8080/v1/handshake', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': 'devkey'
                    },
                    body: JSON.stringify({
                        clientFeatures: {
                            compression: 'zstd',
                            fec: true,
                            maxMtu: 16384
                        },
                        peerAddress: {
                            protocol: 'ws',
                            host: 'localhost',
                            port: 8080
                        }
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    sessionId = data.sessionId;
                    document.getElementById('sessionId').textContent = sessionId;
                    return sessionId;
                } else {
                    throw new Error('Failed to establish session');
                }
            } catch (error) {
                console.error('Session establishment failed:', error);
                addMessage('jsonContainer', 'error', 'Failed to establish session: ' + error.message);
                return null;
            }
        }

        // Connect WebSocket
        async function connectWebSocket() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                return;
            }

            const sessionId = await establishSession();
            if (!sessionId) {
                return;
            }

            ws = new WebSocket(`ws://localhost:8080/v1/messages?sessionId=${sessionId}`);

            ws.onopen = function() {
                updateConnectionStatus(true);
                addMessage('jsonContainer', 'system', 'WebSocket connected successfully!');
            };

            ws.onmessage = function(event) {
                const data = JSON.parse(event.data);
                console.log('Received WebSocket message:', data);
                
                if (data.type === 'recv.plain') {
                    console.log('✅ Translation received:', data.text);
                    addMessage('englishContainer', 'audio', '🤖 AI-Enhanced Translation', null, {
                        text: data.text,
                        confidence: data.confidence,
                        snrDb: data.snrDb || 0
                    });
                    
                    // Update metrics
                    metrics.messagesTranslated++;
                    metrics.averageConfidence = updateAverage(metrics.averageConfidence, data.confidence, metrics.messagesTranslated);
                    updateMetrics();
                    
                    // Add a visual indicator that translation was received
                    const englishContainer = document.getElementById('englishContainer');
                    englishContainer.style.border = '2px solid #2ed573';
                    setTimeout(() => {
                        englishContainer.style.border = '1px solid rgba(255,255,255,0.2)';
                    }, 1000);
                } else if (data.type === 'recv' && data.english) {
                    // Handle the main response with English translation
                    addMessage('englishContainer', 'audio', 'Plain English translation received', null, {
                        text: data.english.text,
                        confidence: data.english.confidence,
                        snrDb: data.snrDb || 0
                    });
                    
                    // Update metrics
                    metrics.messagesTranslated++;
                    metrics.averageConfidence = updateAverage(metrics.averageConfidence, data.english.confidence, metrics.messagesTranslated);
                    updateMetrics();
                } else if (data.type === 'audio.started') {
                    updateAudioStatus(true);
                    addMessage('jsonContainer', 'system', 'Audio capture started');
                } else if (data.type === 'audio.stopped') {
                    updateAudioStatus(false);
                    addMessage('jsonContainer', 'system', 'Audio capture stopped');
                } else if (data.type === 'audio.noise') {
                    addMessage('jsonContainer', 'info', 'Audio received but no FSK signal detected (RMS: ' + data.rms + ')');
                } else if (data.type === 'audio.error') {
                    addMessage('jsonContainer', 'error', 'Audio processing error: ' + data.error);
                } else if (data.type === 'error') {
                    addMessage('jsonContainer', 'error', 'Error: ' + data.message);
                } else {
                    // Log any other messages for debugging
                    console.log('Unhandled message type:', data.type, data);
                    addMessage('jsonContainer', 'info', 'Received: ' + data.type);
                }
            };

            ws.onclose = function() {
                updateConnectionStatus(false);
                addMessage('jsonContainer', 'system', 'WebSocket connection closed');
            };

            ws.onerror = function(error) {
                updateConnectionStatus(false);
                addMessage('jsonContainer', 'error', 'WebSocket error: ' + error.message);
            };
        }

        // Start audio capture
        async function startAudioCapture() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                await connectWebSocket();
            }

            try {
                // Request microphone permission
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                
                // Set up audio context and analyser
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);

                // Start visualization
                const dataArray = new Uint8Array(analyser.frequencyBinCount);
                
                function updateVisualization() {
                    if (!isRecording) return;
                    
                    analyser.getByteFrequencyData(dataArray);
                    drawSpectrum(dataArray);
                    drawWaterfall(dataArray);
                    requestAnimationFrame(updateVisualization);
                }

                isRecording = true;
                updateAudioStatus(true);
                updateVisualization();

                // Send audio start command to WebSocket
                ws.send(JSON.stringify({
                    type: 'audio.start',
                    deviceId: document.getElementById('deviceSelector').value
                }));

                addMessage('jsonContainer', 'system', 'Audio capture started successfully');

            } catch (error) {
                console.error('Failed to start audio capture:', error);
                addMessage('jsonContainer', 'error', 'Failed to start audio capture: ' + error.message);
            }
        }

        // Stop audio capture
        function stopAudioCapture() {
            if (microphone) {
                microphone.disconnect();
                microphone = null;
            }
            
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }

            isRecording = false;
            updateAudioStatus(false);

            // Send audio stop command to WebSocket
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'audio.stop'
                }));
            }

            addMessage('jsonContainer', 'system', 'Audio capture stopped');
        }

        // Start translation
        function startTranslation() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addMessage('englishContainer', 'error', 'WebSocket not connected. Please connect first.');
                return;
            }

            isTranslating = true;
            updateTranslationStatus(true);

            // Send test messages to generate translations
            sendTestMessages();

            // Also start real audio capture
            startRealAudioCapture();

            addMessage('englishContainer', 'system', 'Translation started - sending test messages and listening to microphone');
        }

        // Send test messages to generate translations
        function sendTestMessages() {
            const testMessages = [
                {
                    type: 'audio.frame',
                    msgId: `test_temp_${Date.now()}`,
                    payload: {
                        op: 'sensor_read',
                        sensor: 'temperature',
                        value: 23.5,
                        unit: 'celsius',
                        location: 'server_room_1'
                    },
                    timestamp: new Date().toISOString()
                },
                {
                    type: 'audio.frame',
                    msgId: `test_battery_${Date.now()}`,
                    payload: {
                        op: 'status_check',
                        component: 'battery',
                        level: 75,
                        charging: true,
                        voltage: 12.6
                    },
                    timestamp: new Date().toISOString()
                },
                {
                    type: 'audio.frame',
                    msgId: `test_compute_${Date.now()}`,
                    payload: {
                        op: 'compute_request',
                        task: 'image_processing',
                        parameters: {
                            algorithm: 'convolutional_neural_network',
                            model: 'resnet50',
                            input_size: [224, 224, 3],
                            batch_size: 32
                        },
                        priority: 'high',
                        timeout: 30000
                    },
                    timestamp: new Date().toISOString()
                }
            ];

            // Send test messages with delays
            testMessages.forEach((message, index) => {
                setTimeout(() => {
                    console.log('Sending test message:', message);
                    ws.send(JSON.stringify(message));
                    addMessage('jsonContainer', 'info', `Sent test message ${index + 1}: ${message.payload.op || 'unknown'}`);
                    
                    // Add a placeholder message in Plain English panel
                    addMessage('englishContainer', 'info', `Processing translation for: ${message.payload.op || 'unknown'}...`);
                }, (index + 1) * 2000); // Send every 2 seconds
            });
        }

        // Start real audio capture
        async function startRealAudioCapture() {
            try {
                // Send audio start command to gateway
                ws.send(JSON.stringify({
                    type: 'audio.start'
                }));

                // Set up Web Audio API for real microphone capture
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                // Get microphone stream
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        sampleRate: 48000,
                        channelCount: 1,
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    } 
                });

                microphone = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                analyser.smoothingTimeConstant = 0.8;

                microphone.connect(analyser);

                // Start audio processing
                const dataArray = new Uint8Array(analyser.frequencyBinCount);
                
                // Create audio processor for real FSK demodulation
                const processor = audioContext.createScriptProcessor(4096, 1, 1);
                
                processor.onaudioprocess = function(event) {
                    if (!isTranslating) return;
                    
                    const inputBuffer = event.inputBuffer;
                    const inputData = inputBuffer.getChannelData(0);
                    
                    // Convert to Float32Array for processing
                    const audioData = new Float32Array(inputData);
                    
                    // Check for signal activity
                    const rms = calculateRMS(audioData);
                    
                    if (rms > 0.01) { // Threshold for signal detection
                        // Send real audio data to gateway for FSK demodulation
                        const audioFrame = {
                            msgId: `audio-${Date.now()}`,
                            audioData: Array.from(audioData), // Convert to regular array for JSON
                            sampleRate: audioContext.sampleRate,
                            timestamp: Date.now(),
                            rms: rms
                        };

                        // Send to gateway for real FSK processing
                        const message = {
                            type: 'audio.raw',
                            frame: audioFrame
                        };
                        
                        console.log('Sending audio data to gateway:', message);
                        ws.send(JSON.stringify(message));

                        // Add to JSON container
                        addMessage('jsonContainer', 'audio', 'Real audio data sent for FSK demodulation (RMS: ' + rms.toFixed(3) + ')', audioFrame);
                    }
                };

                microphone.connect(processor);
                processor.connect(audioContext.destination);

                function processAudio() {
                    if (!isTranslating) return;

                    analyser.getByteFrequencyData(dataArray);
                    
                    // Draw spectrum and waterfall
                    drawSpectrum(dataArray);
                    drawWaterfall(dataArray);

                    requestAnimationFrame(processAudio);
                }

                processAudio();

                processAudio();

            } catch (error) {
                console.error('Failed to start audio capture:', error);
                addMessage('englishContainer', 'error', 'Failed to start audio capture: ' + error.message);
                stopTranslation();
            }
        }

        // Generate mock audio payload (simulates decoded audio)
        function generateMockAudioPayload() {
            const payloads = [
                { op: 'sum', args: { a: Math.floor(Math.random() * 100), b: Math.floor(Math.random() * 100) }, id: `audio-${Date.now()}` },
                { op: 'status', component: 'sensor', value: Math.floor(Math.random() * 100) },
                { hello: true, caps: { mtu: 16384, fec: true, compression: 'zstd' } },
                { error: 'AUDIO_ERROR', message: 'Audio processing error', code: 500 }
            ];
            
            return payloads[Math.floor(Math.random() * payloads.length)];
        }

        // Show sample translations directly in the UI
        function showSampleTranslations() {
            const sampleTranslations = [
                {
                    text: "The temperature sensor has recorded a reading of 23.5 degrees Celsius, which falls within the normal operating range. This indicates stable conditions at the time of measurement.",
                    confidence: 0.97,
                    snrDb: 18.5,
                    type: "🌡️ Temperature Sensor"
                },
                {
                    text: "The battery status was checked. Battery level is moderate at 75%. The battery is currently charging.",
                    confidence: 0.95,
                    snrDb: 20.1,
                    type: "🔋 Battery Status"
                },
                {
                    text: "One agent requested another to perform image processing using a convolutional neural network with ResNet50 model, processing 224x224x3 images in batches of 32.",
                    confidence: 1.0,
                    snrDb: 22.4,
                    type: "🧠 AI Compute Request"
                }
            ];

            // Clear existing messages
            const englishContainer = document.getElementById('englishContainer');
            englishContainer.innerHTML = '';

            // Add sample translations
            sampleTranslations.forEach((translation, index) => {
                setTimeout(() => {
                    addMessage('englishContainer', 'audio', `🤖 AI-Enhanced Translation: ${translation.type}`, null, {
                        text: translation.text,
                        confidence: translation.confidence,
                        snrDb: translation.snrDb
                    });
                    
                    // Update metrics
                    metrics.messagesTranslated++;
                    metrics.averageConfidence = updateAverage(metrics.averageConfidence, translation.confidence, metrics.messagesTranslated);
                    updateMetrics();
                    
                    // Add visual indicator
                    englishContainer.style.border = '2px solid #2ed573';
                    setTimeout(() => {
                        englishContainer.style.border = '1px solid rgba(255,255,255,0.2)';
                    }, 1000);
                }, index * 1500); // Show every 1.5 seconds
            });
        }

        // Force real translations to happen
        function forceRealTranslations() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                addMessage('englishContainer', 'error', 'WebSocket not connected. Please connect first.');
                return;
            }

            addMessage('englishContainer', 'system', '🚀 Forcing real translations...');

            const testMessages = [
                {
                    name: '🌡️ Temperature Sensor',
                    payload: {
                        op: 'sensor_read',
                        sensor: 'temperature',
                        value: 23.5,
                        unit: 'celsius',
                        location: 'server_room_1'
                    }
                },
                {
                    name: '🔋 Battery Status',
                    payload: {
                        op: 'status_check',
                        component: 'battery',
                        level: 75,
                        charging: true,
                        voltage: 12.6
                    }
                },
                {
                    name: '🧠 AI Compute Request',
                    payload: {
                        op: 'compute_request',
                        task: 'image_processing',
                        parameters: {
                            algorithm: 'convolutional_neural_network',
                            model: 'resnet50',
                            input_size: [224, 224, 3],
                            batch_size: 32
                        },
                        priority: 'high',
                        timeout: 30000
                    }
                }
            ];

            // Send messages immediately
            testMessages.forEach((testMsg, index) => {
                setTimeout(() => {
                    console.log('🚀 Sending real test message:', testMsg.name);
                    
                    const frame = {
                        type: 'audio.frame',
                        msgId: `force_real_${index}_${Date.now()}`,
                        payload: testMsg.payload,
                        timestamp: new Date().toISOString()
                    };
                    
                    ws.send(JSON.stringify(frame));
                    addMessage('jsonContainer', 'info', `🚀 Sent: ${testMsg.name}`);
                    addMessage('englishContainer', 'info', `⏳ Processing: ${testMsg.name}...`);
                }, index * 1000); // Send every second
            });
        }

        // Stop translation
        function stopTranslation() {
            isTranslating = false;
            updateTranslationStatus(false);

            if (translationInterval) {
                clearInterval(translationInterval);
                translationInterval = null;
            }

            // Stop audio capture
            if (microphone) {
                microphone.disconnect();
                microphone = null;
            }

            // Send audio stop command to gateway
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'audio.stop'
                }));
            }

            addMessage('englishContainer', 'system', 'Real audio translation stopped');
        }

        // Update translation status
        function updateTranslationStatus(translating) {
            const startBtn = document.getElementById('startTranslationBtn');
            const stopBtn = document.getElementById('stopTranslationBtn');
            const statusDot = document.getElementById('translationStatus');
            const statusText = document.getElementById('translationText');

            if (translating) {
                startBtn.style.display = 'none';
                stopBtn.style.display = 'inline-flex';
                statusDot.classList.add('recording');
                statusText.textContent = 'Translation: Active';
            } else {
                startBtn.style.display = 'inline-flex';
                stopBtn.style.display = 'none';
                statusDot.classList.remove('recording');
                statusText.textContent = 'Translation: Stopped';
            }
        }

        // Get audio devices
        async function getAudioDevices() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const audioDevices = devices.filter(device => device.kind === 'audioinput');
                
                const selector = document.getElementById('deviceSelector');
                selector.innerHTML = '<option value="">Select microphone...</option>';
                
                audioDevices.forEach(device => {
                    const option = document.createElement('option');
                    option.value = device.deviceId;
                    option.textContent = device.label || `Microphone ${device.deviceId.slice(0, 8)}`;
                    selector.appendChild(option);
                });
            } catch (error) {
                console.error('Failed to get audio devices:', error);
            }
        }

        // Calculate RMS (Root Mean Square) for audio signal strength
        function calculateRMS(audioData) {
            let sum = 0;
            for (let i = 0; i < audioData.length; i++) {
                sum += audioData[i] * audioData[i];
            }
            return Math.sqrt(sum / audioData.length);
        }

        // Update average helper function
        function updateAverage(current, newValue, count) {
            return (current * (count - 1) + newValue) / count;
        }

        // Initialize
        function init() {
            initCanvas();
            getAudioDevices();
            updateMetrics();
            
            // Auto-connect WebSocket
            connectWebSocket();
        }

        // Start initialization
        init();
    </script>
</body>
</html>